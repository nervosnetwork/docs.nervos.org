---
id: basic-script
title: "Basic Script Example"
sidebar_position: 6
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import ScriptHeaders from "./ScriptHeaders.tsx";
import TutorialHeader from "@components/TutorialHeader";

# Basic Script Example

<TutorialHeader
  time={ScriptHeaders.basic.time}
  topics={ScriptHeaders.basic.topics}
  tools={ScriptHeaders.basic.tools}
/>

## What is Script

A [script](/docs/concepts/glossary#script) in Nervos CKB is a binary executable that can be executed on-chain. It is Turing-complete and can perform arbitray logic to guard and protect your on-chain assets. You can think of it as smart contract.

### How does Script works

When executing a script, CKB just take the executables and run it in a virtual machine environment called [CKB-VM](/docs/concepts/ckb-vm). After the execution, if the program returns with 0 as the return code, we consider the script succeeds, all non-zero return codes will be considered script faliures. 

When you submit a transaction to CKB, CKB will execute all the scripts from the transaction to ensure that all scripts succeeds, otherwiese the transaction will fail to be included on-chain.


### Script structure

A Script can be one of two types:

- Lock Script - Used to control ownership and access to a Cell.
- Type Script - Used to control how a Cell is used in a transaction.

Script has the following structure:

```rust
pub struct Script {
    pub code_hash: H256,
    pub hash_type: ScriptHashType,
    pub args: JsonBytes,
}
```

The `code_hash` actually just identifies a script code so that `CKB-VM` knows how to load the binary code of the script. 

What script also includes, is the `args` part, which distinguishes script from script code. args can be used here to provide additional arguments for a CKB script, for example, while people might all be using the same default lock script code, each of them might have their own pubkey hash, args is exact the place to hold pubkey hash. This way each user of CKB can have different lock script, while sharing the same lock script code.

`hash_type` denotes different ways for `CKB-VM` to locate the script code for a script. Possible values include `type`, `data`, `data1` and `data2`.

## A Minimal Script

How do we write a script then? 

Different from other blockchains, the CKB-VM is more like a real mini computer. CKB script code also looks like a normal Unix style executable program we run on a computer. 

You can acutlly write scripts in any program language you want as long as you have the proper toolchain. But in this website, we will use `Rust` as the program language to show how to write a script.

As we have mentioned before, a script returns 0 means it succeeds. A simplest CKB script code looks like this:

```rust
pub fn program_entry() -> i8 {
    0
}
```

This simplest script code is called `always-success` since it always return 0 as its return code. You might think this simplest script code is also the dumplest one, because if you use this as your lock script code, your token can be taken away by anyone. 

But such simpleset script code turns out to be useful under development environment. When you are testing some scripts on local blockchain for your dApp, you might let the testing cells to have `always-success` lock script to simplify your testing work flow.

But the `always-success` won‚Äôt be interesting since it is too simple. 

Here we will start with an interesting idea: 

> personally I dislike carrot. I do know that carrot is great from a nutritional point of view, but I still want to avoid it due to the taste. Now what if I want to set a rule, that none of my cells on CKB has data that begin with the word `carrot`? 

Let‚Äôs write a script code to ensure this. Below is a step by step guide, you can also clone the full code example from github [carrot-script](https://github.com/nervosnetwork/docs.nervos.org/tree/develop/examples/carrot-script)

### Carrot-forbidden Script

The first step is to create a new Script project. We use [ckb-script-templates](https://github.com/cryptape/ckb-script-templates) to do that. You need the following dependencies:

* `git`, `make`, `sed`, `bash`, `sha256sum` and others Unix utilities
* `Rust` with `riscv64` target installed: `rustup target add riscv64imac-unknown-none-elf`
* `Clang 16+`
* `cargo-generate`: You can install this via `cargo install cargo-generate`

If you got any problems for these dependencies, refer to [readme](https://github.com/cryptape/ckb-script-templates?tab=readme-ov-file#dependencies) for install details.

### Init a Script project

Now let's run the command to generate a new Script project called `my-first-contract-workspace`:

```mdx-code-block
<Tabs>
  <TabItem value="init-script" label="Command">
```
```bash {5}
alias create-ckb-scripts="cargo generate gh:cryptape/ckb-script-templates workspace"
create-ckb-scripts
```
```mdx-code-block
  </TabItem>
  <TabItem value="init-script-result" label="Response">
```
```bash
‚ö†Ô∏è   Favorite `gh:cryptape/ckb-script-templates` not found in config, using it as a git repository: https://github.com/cryptape/ckb-script-templates.git
ü§∑   Project Name: my-first-contract-workspace
üîß   Destination: /tmp/my-first-contract-workspace ...
üîß   project-name: my-first-contract-workspace ...
üîß   Generating template ...
üîß   Moving generated files into: `/tmp/my-first-contract-workspace`...
üîß   Initializing a fresh Git repository
‚ú®   Done! New project created /tmp/my-first-contract-workspace
```
```mdx-code-block
  </TabItem>
</Tabs>
```

### Create a new Script

Let‚Äôs create a new script called `carrot`.

```mdx-code-block
<Tabs>
  <TabItem value="create-a-new-script" label="Command">
```
```bash {5}
cd my-first-contract-workspace
make generate
```
```mdx-code-block
  </TabItem>
  <TabItem value="create-a-new-script-result" label="Response">
```
```bash
ü§∑   Project Name: carrot
üîß   Destination: /tmp/my-first-contract-workspace/contracts/carrot ...
üîß   project-name: carrot ...
üîß   Generating template ...
üîß   Moving generated files into: `/tmp/my-first-contract-workspace/contracts/carrot`...
üîß   Initializing a fresh Git repository
‚ú®   Done! New project created /tmp/my-first-contract-workspace/contracts/carrot
```
```mdx-code-block
  </TabItem>
</Tabs>
```

Our project is successfully setup! You can run `tree .` to show the project structure:

```mdx-code-block
<Tabs>
  <TabItem value="script-project-structure" label="Command">
```
```bash {5}
cd my-first-contract-workspace
tree .
```
```mdx-code-block
  </TabItem>
  <TabItem value="script-project-structure-result" label="Response">
```
```bash
.
‚îú‚îÄ‚îÄ Cargo.lock
‚îú‚îÄ‚îÄ Cargo.toml
‚îú‚îÄ‚îÄ Makefile
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ contracts
‚îÇ   ‚îî‚îÄ‚îÄ carrot
‚îÇ       ‚îú‚îÄ‚îÄ Cargo.toml
‚îÇ       ‚îú‚îÄ‚îÄ Makefile
‚îÇ       ‚îú‚îÄ‚îÄ README.md
‚îÇ       ‚îî‚îÄ‚îÄ src
‚îÇ           ‚îî‚îÄ‚îÄ main.rs
‚îú‚îÄ‚îÄ scripts
‚îÇ   ‚îî‚îÄ‚îÄ find_clang
‚îî‚îÄ‚îÄ tests
    ‚îú‚îÄ‚îÄ Cargo.toml
    ‚îî‚îÄ‚îÄ src
        ‚îú‚îÄ‚îÄ lib.rs
        ‚îî‚îÄ‚îÄ tests.rs

7 directories, 13 files
```
```mdx-code-block
  </TabItem>
</Tabs>
```

A litter introduce here: `contracts/carrot/src/main.rs` contains our source code of the carrot script. the `tests/tests.rs` provide unit test for our scripts. We will introduce tests after we write the script.

### Use CKB syscall with ckb-std

To ensure the security of CKB script, each script has to run in an isolated environment that is totally separated from the main computer you are running CKB. This way it won‚Äôt be able to access data it doesn‚Äôt need, such as your private keys or passwords. 

However, for a script to be useful, there must be certain data it want to access, such as the cell a script guards, or a transaction a script validates. CKB provides [syscalls](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0009-vm-syscalls/0009-vm-syscalls.md) to ensure this, syscalls are defined in RISC-V standard, they provide a way to access certain resources provided by the environment. In a normal situation, the environment here means the operating system, but in the case of CKB VM, the environment refers to the actual CKB process. With syscalls, a CKB script can access the whole transaction containing itself, including inputs, outputs, witnesses, and deps.

The good news, is that we have encapsulated syscalls in an easy to use library called [ckb-std](https://docs.rs/ckb-std/latest/ckb_std/) in Rust, you are very welcome to poke around the [source code](https://github.com/nervosnetwork/ckb-std) of this library to see how syscalls are implemented. The bottomline is you can just grab this library and use the wrapped functions to make syscalls as you want.

For our carrot-forbidden script to ensure none of the cells can have carrot in cell data, we will use CKB syscall to read cell data in the script.

Open `my-first-contract-workspace/contracts/carrot/src/main.rs` and change it to the following:

```rust title="my-first-contract-workspace/contracts/carrot/src/main.rs"
#![no_std]
#![cfg_attr(not(test), no_main)]

#[cfg(test)]
extern crate alloc;

mod error;

use ckb_std::{ckb_constants::Source, debug, error::SysError, high_level::load_cell_data};

#[cfg(not(test))]
use ckb_std::default_alloc;
use error::Error;
#[cfg(not(test))]
ckb_std::entry!(program_entry);
#[cfg(not(test))]
default_alloc!();

pub fn program_entry() -> i8 {    
    match carrot_forbidden() {
        Ok(_) => 0,
        Err(err) => err as i8,
    }
}

fn carrot_forbidden() -> Result<(), Error> {
    let mut index = 0;
    loop {
        match load_cell_data(index, Source::GroupOutput) {
            Ok(data) => {
                if data.starts_with("carrot".as_bytes()) {
                    return Err(Error::CarrotAttack);
                }else{
                    debug!("output #{:} has no carrot! Hooray!", index);
                }
            },
            Err(err) => {
                match err {
                    // we loop out all the output cell
                    SysError::IndexOutOfBound => break,
                    _ => return Err(Error::from(err)),
                }
            }
        }
        // Increment index to process next cell
        index += 1;
    }
    Ok(())
}
```

We also need to a `Error` module to define the error code when carrot script fails. Create a new file named `error.rs` in `my-first-contract-workspace/contracts/carrot/src/error.rs`:

```rs title="my-first-contract-workspace/contracts/carrot/src/error.rs"
use ckb_std::error::SysError;

#[cfg(test)]
extern crate alloc;

#[repr(i8)]
pub enum Error {
    IndexOutOfBound = 1,
    ItemMissing,
    LengthNotEnough,
    Encoding,
    // Add customized errors here...
    CarrotAttack,
}

impl From<SysError> for Error {
    fn from(err: SysError) -> Self {
        match err {
            SysError::IndexOutOfBound => Self::IndexOutOfBound,
            SysError::ItemMissing => Self::ItemMissing,
            SysError::LengthNotEnough(_) => Self::LengthNotEnough,
            SysError::Encoding => Self::Encoding,
            SysError::Unknown(err_code) => panic!("unexpected sys error {}", err_code),
        }
    }
}
```

Several points worth explaining here:

To load cell data, we use `load_cell_data` syscall from `ckb-std` library. the function takes two arguments, one is the index number, and one is source type flag that denoting the source of cells to locate. Different source type and index number will point to different cell. For example, `load_cell_data(0, Source::GroupOutput)` means load the first cell from the output cells group with the same running script as current script. You can check [rfc](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0046-syscalls-summary/0046-syscalls-summary.md#source) for more details.

The workflow of our script goes like this: 

First, it loops through all output cells in the transaction, load each cell data and test if those bytes match the word `carrot`. If we found a match, the script would return -1, denoting an error status, if no match is found, the script exits with 0, meaning execution success.

To perform the loop, the script would keep an index variable, in each loop iteration, it would tries to make the syscall to fetch the cell denoted by current index value, if the syscall returns CKB_INDEX_OUT_OF_BOUND, it means the script has iterated through all the cells, hence it just exits the loop, otherwise, the loop would continue, the cell data is tested, then index variable is incremented for the next iteration.

Besides the main logic in `main.rs` file, we also write a `error.rs` to define our custom error code for the carrot script. CKB defines some basic error code like:

- 1(CKB_INDEX_OUT_OF_BOUND) means you have finished fetching all indices in a kind
- 2(CKB_ITEM_MISSING) means an entity is not present, such as fetching a type script from a cell that doesn‚Äôt have one.
- 3(CKB_LENGTH_NOT_ENOUGH) means some data length is wrong such as invalid script args or signature length.
- 4(CKB_INVALID_DATA) means there is something wrong with the [molecule serialization](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0008-serialization/0008-serialization.md).

We define error code 5 to be the custom `CarrotAttack` error. So everytime the script throws out error code 5, we know that means the script have found a cell data starts with the `carrot` word so it fails.

So that's all! This concludes your first useful CKB script code! 

In the next section, we will see how we can test and deploy it to CKB and run it.

### Testing your script

`ckb-script-templates` packs the unit test section that we can use to quickly test our script without deploying the script to blockchains.

All test case goes into the `my-first-contract-workspace/tests/src/tests.rs` file. The way tests works is to leverage a library called [ckb_testtool](https://docs.rs/ckb-testtool/latest/ckb_testtool/) to simulate the execution of the script.

```rust title="my-first-contract-workspace/tests/src/tests.rs"
// Include your tests here
// See https://github.com/xxuejie/ckb-native-build-sample/blob/main/tests/src/tests.rs for examples

use super::*;
use ckb_testtool::{
    builtin::ALWAYS_SUCCESS,
    ckb_types::{bytes::Bytes, core::TransactionBuilder, packed::*, prelude::*},
    context::Context,
};

const MAX_CYCLES: u64 = 10_000_000;

#[test]
fn test_no_carrot() {
    // deploy contract
    let mut context = Context::default();
    let loader = Loader::default();
    let carrot_bin = loader.load_binary("carrot");
    let carrot_out_point = context.deploy_cell(carrot_bin);
    let carrot_cell_dep = CellDep::new_builder()
        .out_point(carrot_out_point.clone())
        .build();

    // prepare scripts
    let always_success_out_point = context.deploy_cell(ALWAYS_SUCCESS.clone());
    let lock_script = context
        .build_script(&always_success_out_point.clone(), Default::default())
        .expect("script");
    let lock_script_dep = CellDep::new_builder()
        .out_point(always_success_out_point)
        .build();

    // prepare cell deps
    let cell_deps: Vec<CellDep> = vec![lock_script_dep, carrot_cell_dep];

    // prepare cells
    let input_out_point = context.create_cell(
        CellOutput::new_builder()
            .capacity(1000u64.pack())
            .lock(lock_script.clone())
            .build(),
        Bytes::new(),
    );
    let input = CellInput::new_builder()
        .previous_output(input_out_point.clone())
        .build();

    let type_script = context
        .build_script(&carrot_out_point, Bytes::new())
        .expect("script");

    let outputs = vec![
        CellOutput::new_builder()
            .capacity(500u64.pack())
            .lock(lock_script.clone())
            .type_(Some(type_script.clone()).pack())
            .build(),
        CellOutput::new_builder()
            .capacity(500u64.pack())
            .lock(lock_script)
            .build(),
    ];

    // prepare output cell data
    let outputs_data = vec![Bytes::from("apple"), Bytes::from("tomato")];

    // build transaction
    let tx = TransactionBuilder::default()
        .cell_deps(cell_deps)
        .input(input)
        .outputs(outputs)
        .outputs_data(outputs_data.pack())
        .build();

    let tx = tx.as_advanced_builder().build();

    // run
    let cycles = context
        .verify_tx(&tx, MAX_CYCLES)
        .expect("pass verification");
    println!("consume cycles: {}", cycles);
}
```

As you can see, we wrote the first test case named `test_no_carrot` to simulate a transaction that use our carrot-forbidden script in one of the output cell, and we build all the output cell without `carrot` in their cell data. To make the test pass, the transaction should be valid and verified by CKB successfully.

We can also write another test that simulates if the transaction does contains output cell that its data starts with the word `carrot`:

```rust title=""
#[test]
fn test_carrot_attack() {
    // deploy contract
    let mut context = Context::default();
    let loader = Loader::default();
    let carrot_bin = loader.load_binary("carrot");
    let carrot_out_point = context.deploy_cell(carrot_bin);
    let carrot_cell_dep = CellDep::new_builder()
        .out_point(carrot_out_point.clone())
        .build();

    // prepare scripts
    let always_success_out_point = context.deploy_cell(ALWAYS_SUCCESS.clone());
    let lock_script = context
        .build_script(&always_success_out_point.clone(), Default::default())
        .expect("script");
    let lock_script_dep = CellDep::new_builder()
        .out_point(always_success_out_point)
        .build();

    // prepare cell deps
    let cell_deps: Vec<CellDep> = vec![lock_script_dep, carrot_cell_dep];

    // prepare cells
    let input_out_point = context.create_cell(
        CellOutput::new_builder()
            .capacity(1000u64.pack())
            .lock(lock_script.clone())
            .build(),
        Bytes::new(),
    );
    let input = CellInput::new_builder()
        .previous_output(input_out_point.clone())
        .build();

    let type_script = context
        .build_script(&carrot_out_point, Bytes::new())
        .expect("script");

    let outputs = vec![
        CellOutput::new_builder()
            .capacity(500u64.pack())
            .lock(lock_script.clone())
            .type_(Some(type_script.clone()).pack())
            .build(),
        CellOutput::new_builder()
            .capacity(500u64.pack())
            .lock(lock_script)
            .build(),
    ];

    // prepare output cell data
    let outputs_data = vec![Bytes::from("carrot"), Bytes::from("tomato")];

    // build transaction
    let tx = TransactionBuilder::default()
        .cell_deps(cell_deps)
        .input(input)
        .outputs(outputs)
        .outputs_data(outputs_data.pack())
        .build();

    let tx = tx.as_advanced_builder().build();

    // run
    let err = context.verify_tx(&tx, MAX_CYCLES).unwrap_err();
    assert_script_error(err, 5);
}

fn assert_script_error(err: Error, err_code: i8) {
    let error_string = err.to_string();
    assert!(
        error_string.contains(format!("error code {} ", err_code).as_str()),
        "error_string: {}, expected_error_code: {}",
        error_string,
        err_code
    );
}
```

In this test, we check if the error code throws by our script is matched with the error code 5 in `assert_script_error(err, 5);`.

---

## Congratulations!

By following this tutorial this far, you have mastered how to write a basic script on CKB. Here's a quick recap:

- Use `ckb-script-templates` to init a script project
- Use `ckb-std` to leverage CKB syscalls to read all kinds of data from transaction.
- Use unit tests without deploying the script to blockchains to quickly test the script.

## Additional Resources

- This tutorial is originally taken and adapt from the amazing blog post by [xuejie.space](https://xuejie.space/2019_07_13_introduction_to_ckb_script_programming_script_basics/)
- Full source code of this tutorial: [carrot-script](https://github.com/nervosnetwork/docs.nervos.org/tree/develop/examples/carrot-script)
- CKB syscalls specs: [RFC-0009](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0009-vm-syscalls/0009-vm-syscalls.md)
- script templates: [ckb-script-templates](https://github.com/cryptape/ckb-script-templates)
- CKB transaction structure: [RFC-0022-transaction-structure](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0022-transaction-structure/0022-transaction-structure.md)
- CKB data structure basics: [RFC-0019-data-structure](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0019-data-structures/0019-data-structures.md)
