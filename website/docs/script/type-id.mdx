---
id: type-id
title: "Tutorial: Type ID (Upgradable Script)"
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import ScriptHeaders from "./ScriptHeaders.tsx";
import TutorialHeader from "@components/TutorialHeader";
import ScriptTools from "./_ScriptTools.mdx";

# Tutorial: Type ID (Upgradable Script)

<TutorialHeader
  time={ScriptHeaders.typeid.time}
  topics={ScriptHeaders.typeid.topics}
  tools={ScriptHeaders.typeid.tools}
/>

Smart contracts are codes that got executed on-chain that nobody can stops. However, sometimes you might want to implement some kind of upgradability for your smart contract in case there are bugs in the source code.

In CKB, there is a commomly used pattern called [Type ID](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0022-transaction-structure/0022-transaction-structure.md#type-id) to leverage the `hash_type` field in CKB's Script structure to make your Script upgradable. We will explorer this idea in the post.

## Write A Unique Type Script

Let's first ask a question: how can we create a type Script that ensures only one live cell in CKB can have that unique type Script? By unique type Script, we mean the whole type Script structure, including `code_hash`, `hash_type` and `script_args`.

Note that this question might seem irrelevant to Script upgradability right now, but please bear with me, we will see how it will contribute to the final solution in CKB.

The answer is quite simple, here's the basic workflow of the Script:

1. Count how many output cells use current type Script, if there's more than one cell with current type Script, returns a failure return code;
2. Count how many input cells use current type Script, if there's one input cell with current type Script, returns a success return code;
3. Use CKB syscall to read the first OutPoint in current transaction;
4. If the OutPoint data read match the `args` part of current type Script, returns a success return code;
5. Returns a failure return code otherwise.

Putting in simple C code, the Script would look like following:

```c
#include "blockchain.h"
#include "ckb_syscalls.h"

#define INPUT_SIZE 128
#define SCRIPT_SIZE 32768

int main() {
  uint64_t len = 0;
  int ret = ckb_load_cell(NULL, &len, 0, 1, CKB_SOURCE_GROUP_OUTPUT);
  if (ret != CKB_INDEX_OUT_OF_BOUND) {
    return -1;  /* 1 */
  }

  len = 0;
  ret = ckb_load_cell(NULL, &len, 0, 0, CKB_SOURCE_GROUP_INPUT);
  if (ret != CKB_INDEX_OUT_OF_BOUND) {
    return 0;  /* 2 */
  }

  /* 3 */
  unsigned char input[INPUT_SIZE];
  uint64_t input_len = INPUT_SIZE;
  ret = ckb_load_input(input, &input_len, 0, 0, CKB_SOURCE_INPUT);
  if (ret != CKB_SUCCESS) {
    return ret;
  }
  if (input_len > INPUT_SIZE) {
    return -100;
  }

  unsigned char Script[SCRIPT_SIZE];
  len = SCRIPT_SIZE;
  ret = ckb_load_script(Script, &len, 0);
  if (ret != CKB_SUCCESS) {
    return ret;
  }
  if (len > SCRIPT_SIZE) {
    return -101;
  }
  mol_seg_t script_seg;
  script_seg.ptr = (uint8_t *)Script;
  script_seg.size = len;

  if (MolReader_Script_verify(&script_seg, false) != MOL_OK) {
    return -102;
  }

  mol_seg_t args_seg = MolReader_Script_get_args(&script_seg);
  mol_seg_t args_bytes_seg = MolReader_Bytes_raw_bytes(&args_seg);

  if ((input_len == args_bytes_seg.size) &&
      (memcmp(args_bytes_seg.ptr, input, input_len) == 0)) {
    /* 4 */
    return 0;
  }
  return -103;
}
```

Attackers will be prevented in several different directions:

1. If an attacker tries to create a cell with the exactly same type Script, there will be 2 cases:
   a. A valid transaction will have different OutPoint data in the first input from the type Script args;
   b. If the user tries to duplicate type Script args as the first transaction input, CKB will signal a double-spent error;
2. If the attacker tries to use a different type Script args, it will be a different type Script by definition.

This way, we can ensure a cell will have unique type Script across all live cells in CKB. Considering each Script has an associated hash, we will have a cell in CKB with its unique hash, or unique ID.

## Resolving Scripts in CKB Transaction

Now let's look at how CKB resolves the Script to run before the `hash_type` change:

- CKB extracts `code_hash` value from the Script structure to run.
- It loops through all dep cells, computes the hash of each dep cell data. If any dep cell data hash matches the specified `code_hash`, CKB uses the data in the found dep cell as the Script to run.
- If no dep cell has data hash matching specified `code_hash`, CKB results in a validation error.

The upgradability problem, in fact lies in the way we test for dep cells. Right now we are testing against data hash, and when a Script is upgraded, a different hash will be generated, the matching would fail. That brings a question: can we test for dep cells using a different solution? Is there something that can stay unchanged when the Script is changed? Considering the actual Script to run lives in a cell, we can rephrase the question in a different way:

Is there something that can stay unchanged when a cell's data get updated?

We can use a Script structure! Since lock Script is typically used for signature verification, we can use a type Script for this problem. A type Script can stay perfectly unchanged when a cell's data get changed. Hence we added `hash_type` field to CKB's Script structure, and modified the Script resolving flow to the following:

- For each dep cell, we extract the `test hash` based on `hash_type` value in the Script structure:
  - If `hash_type` is `data`, the dep cell's data hash is used as `test hash`
  - If `hash_type` is `type`, the dep cell's type Script hash is used as `test hash`
- CKB extracts `code_hash` and `hash_type` values from the Script structure to run
- If CKB finds a dep cell whose `test hash` matches specified `code_hash`, CKB uses the data in the found dep cell as the scrip to run.
- If no dep cell has `test hash` matching specified `code_hash`, CKB results in a validation error.

Notice the `hash_type` used here, is the value belonging to the Script to run, not the values of scripts in a dep cell. You could perfectly have 2 inputs in a transaction, one using `data` as `hash_type`, the other using `type` as `hash_type`. Either one of them will use its own correct way to locate the correct cell.

This way we have totally conquered determinism property A above, but for property B there will be some subtle affects, we will discuss those in more details below.

## Putting Everything Together

There's still one problem unsolved, there might still be an attack:

- A lock Script L1 is stored in a cell C1 with type Script T1
- Alice guards her cells via lock Script L1 using `hash_type` as `type`, by definition, she fills her Script structure's `code_hash` field with the hash of type Script T1
- Bob creates a different cell C2 with a always success lock Script L2, and also use the same type Script T1
- Now Bob can use C2 as a dep cell to unlock Alice's cell. CKB won't be able to distinguish that Alice wants to use C1, while Bob provides C2. Both C1 and C2 use T1 as type Script

That teaches us a very important lesson: if you build a lock/type Script and want people to leverage the upgradability property, you have to make sure to use a type Script that is unique and unforgeable.

Luckily, we just solved this problem! In the above we just developed a type Script that can provide a unique type Script hash in CKB. Combined together, this unique type Script and `hash_type` feature in CKB provide a way to upgrade already deployed smart contracts.

## Type-ID as a Genesis Script

The Type ID type Script can be implemented as an ordinaly Script, but CKB team choose to implement it in the CKB node as a special genesis Script. Because if we want to make it upgradable, it has to use itself as the type Script via type Script hash, which is a recursive dependency.

As a genesis Script, the Type ID code cell uses a special type Script hash, which is just the ascii codes in hex of the text `TYPE_ID`.

```
0x00000000000000000000000000000000000000000000000000545950455f4944
```

## Integrate Type-ID in Your Script

There are several Rust implementations of `Type-ID` Script you can take as reference to integrate in your Script.

- https://github.com/cryptape/nostr-binding/blob/main/contracts/nostr-binding/src/type_id.rs
- https://github.com/axonweb3/ckb-type-id

```rust
use alloc::vec::Vec;
use blake2b_ref::Blake2bBuilder;
use ckb_std::{
    ckb_constants::Source,
    ckb_types::prelude::Entity,
    debug,
    error::SysError,
    high_level::{load_cell_type_hash, load_input, load_script_hash},
    syscalls::load_cell,
};

use super::Error;

pub fn has_type_id_cell(index: usize, source: Source) -> bool {
    let mut buf = Vec::new();
    match load_cell(&mut buf, 0, index, source) {
        Ok(_) => true,
        Err(e) => {
            // just confirm cell presence, no data needed
            if let SysError::LengthNotEnough(_) = e {
                return true;
            }
            false
        }
    }
}

fn locate_first_type_id_output_index() -> Result<usize, Error> {
    let current_script_hash = load_script_hash()?;

    let mut i = 0;
    loop {
        let type_hash = load_cell_type_hash(i, Source::Output)?;

        if type_hash == Some(current_script_hash) {
            break;
        }
        i += 1
    }
    Ok(i)
}

/// Given a 32-byte type id, this function validates if
/// current transaction confronts to the type ID rules.
pub fn validate_type_id(type_id: [u8; 32]) -> Result<(), Error> {
    if has_type_id_cell(1, Source::GroupInput) || has_type_id_cell(1, Source::GroupOutput) {
        debug!("There can only be at most one input and at most one output type ID cell!");
        return Err(Error::TooManyTypeIdCell);
    }

    if !has_type_id_cell(0, Source::GroupInput) {
        // We are creating a new type ID cell here. Additional checkings are needed to ensure the type ID is legit.
        let index = locate_first_type_id_output_index()?;
        // The type ID is calculated as the blake2b (with CKB's personalization) of
        // the first CellInput in current transaction, and the created output cell
        // index(in 64-bit little endian unsigned integer).
        let input = load_input(0, Source::Input)?;
        let mut blake2b = Blake2bBuilder::new(32)
            .personal(b"ckb-default-hash")
            .build();
        blake2b.update(input.as_slice());
        blake2b.update(&index.to_le_bytes());
        let mut ret = [0; 32];
        blake2b.finalize(&mut ret);

        if ret != type_id {
            debug!("Invalid type ID!");
            return Err(Error::TypeIdNotMatch);
        }
    }
    Ok(())
}
```
