---
id: vm-selection
title: "VM Version Selection"
---

When you wrote a Script, it is important to understand how this Script will be executed in a determined CKB-VM version. There are different CKB-VM versions in CKB network since it's essential to keep improving CKB-VM to for security, performance, bug fixings and new RISC-V extensions. However the upgrade should not break the old code, users must have the opt-in option to specify the VM version.

This article explains the general mechanism that determines how the CKB node chooses the CKB-VM version for a transaction Script group based on [RPC-32](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0032-ckb-vm-version-selection/0032-ckb-vm-version-selection.md).

## How It Works

In CKB, each VM version has its bundled instruction set, syscalls and cost model.

Typically, when a CKB Hard Fork takes effect from an epoch decided by the community consensus, all the transactions in the blocks before the activation epoch must run the previous CKB-VM version to verify all the Script groups.

After the fork is activated, CKB nodes must choose the CKB-VM version for each Script group. This is done by checking the value of `hash_type` field in the Script Structure. The allowed values for the `hash_type` are 0, 1, 2 and 4. Cells are sorted into different groups if they have different `hash_type`.

According to the value of `hash_type`:

- When the `hash_type` is 0, the Script group matches code via `data hash` and will run the code using the CKB-VM version 0.
- When the `hash_type` is 1, the Script group matches code via `type Script hash` and will run the code using the CKB-VM version 2.
- When the `hash_type` is 2, the Script group matches code via `data hash` and will run the code using the CKB-VM version 1.
- When the `hash_type` is 4, the Script group matches code via `data hash` and will run the code using the CKB-VM version 2.

| `hash_type` | JSON Representation | Matched by          | VM Version |
| ----------- | ------------------- | ------------------- | ---------- |
| 0           | “data”              | Data hash (blake2b) | 0          |
| 1           | “type”              | Type Script hash    | 2          |
| 2           | “data1”             | Data hash (blake2b) | 1          |
| 4           | “data2”             | Data hash (blake2b) | 2          |

The `hash_type` encoding pattern ensures that if a Script matches code via `type hash`, CKB always uses the latest available version of VM depending when the Script is executed. But if the Script matches code via `data hash`, the VM version to execute is determined when the Cell is created.

Cell owners can trade off between the determination and VM performance boost when creating the Cell. They should use `data hash` for determination, and `type hash` for the latest VM techniques.

## **Rationale**

There are many other solutions to select VM versions. The current solution results from discussion and trade-off. Following are some example alternatives:

- Consistently uses the latest VM version. The users cannot specify the VM versions for transactions, and the version selection will be non-determine cause it will depend on the chain state.
- Depend on the Script code Cell epoch. Use the old VM version if the code Cell is deployed before the fork, and use the new one otherwise. The problem with this solution is that anyone can re-deploy the Cell and construct the transaction using the new code Cell to choose VM versions.

## Backward compatibility

For Cell Scripts which reference codes via `data hash`, they will use the same VM before and after the hard fork. For those referenced by `type hash`, they will use the different VM versions. The dApps developers must ensure the compatibility of their Scripts and upgrade them if necessary.
